# 网络相关

## 说一下你对 http 状态码的了解

- 1xx（信息性状态码）：表示临时响应并需要请求者继续执行操作的状态代码，表明接收的请求正在处理
- 2xx（成功状态码）：表示请求正常处理完毕
	- 200 OK：表示请求被成功处理
	- 204 NoContent：请求处理成功，但没有资源返回
	- 206 Partial Content：客户端进行了范围请求，服务端成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。
- 3xx（重定向状态码）：表示需要进行附加操作以完成请求
	- 301：资源的永久性重定向（用户保存的书签会改变）
	- 302：临时性重定向（书签不会改变）
	- 303：请求的资源中有其他 URL，要求必须使用 GET 方法去请求该资源
	- 301/302/303：响应状态码返回时，浏览器会把 POST 改为 GET 请求并重新发送，虽然标准是禁止的，但大家都会这么做
	- 304：表示客户端发送**附带条件的请求（if-Match 等）**时，服务器端允许请求访问资源，但未满足条件的情况。
	- 307：临时重定向，但是不同于 302，不会将 POST 改为 GET 请求重新发送。
- 4xx（客户端错误状态码）：表示服务器无法处理请求
	- 400：表示请求报文中存在语法错误，需要修改并重新请求。会像 200 OK 一样对待该状态码。
	- 401：表示发送的请求有需要通过认证的地方（如登录等），需要重新验证信息并请求，如果之前已经有过一次该请求，则表明用户认证失败。
	- 403：表名请求资源的访问被服务器拒绝了，客户端没有访问权限等一系列原因。
	- 404：服务器找不到请求的资源。
- 5xx（服务器错误状态码）：表示服务器处理请求出错
	- 500：表明服务器端在执行请求时发生了错误
	- 503：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求



## 说一下从输入 URL 到页面加载完中间发生了什么

大致过程是这样的：

1. 对网址进行DNS域名解析（DNS域名服务器），得到对应的 IP 地址

2. 跟据这个IP，找到对应的服务器，发起TCP连接（三次握手）

3. 建立连接后发送HTTP请求

4. 服务器处理请求并返回需要的数据

5. 浏览器解析数据并渲染页面（解析得到的html代码后会再去请求代码中的 资源（js，css，图片等））

6. 关闭连接，连接结束

输入了一个域名，域名要通过 DNS 解析找到这个域名对应的服务器地址 (ip) ，通过 TCP 请求链接服务，通过 web 服务器 (apache) 返回数据，浏览器根据返回数据构建 DOM 树，通过 css 渲染引擎及 js 解析引擎将页面渲染出来，关闭tcp连接。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230508103634086.png" alt="image-20230508103634086" style="zoom:67%;" />



### DNS 域名如何解析的

1. DNS域名解析采用的是递归查询的方式，先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，递归查找之后，找到了，给我们的web浏览器。
2. 浏览器首先搜索自身的DNS缓存，看缓存中是否有 www.abc.com 这个域名，有而且没有过期的话，解析结束。
3. 如果浏览器自身的缓存中没有找到，则会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索，解析到此结束。
4. 如果在操作系统的DNS缓存中也没有找到，那么尝试读取hosts文件，有则解析成功，解析到此结束。
5. 如果在hosts文件中也没有找到，浏览器会发起一个DNS（Domain Name System：域名服务协议）系统调用，向本地配置的首选DNS服务器发起域名解析请求 （递归请求）：
	1. 运营商的DNS服务器首先查找自身的缓存，如果能找到且没有过期则解析成功。
	2. 如果没有找到，则运营商的DNS代我们的浏览器发起迭代DNS解析请求。
	3. 运营商DNS首先会查找根域DNS的IP地址（这个DNS服务器内置13台根DNS域服务器的IP地址），找到根域的DNS地址，就会向其发起请求（（问一下www.abc.com这个域名的ip地址是多少啊？））。根域发现这是一个com域（顶级域）的域名，于是返回com域的IP地址，然后运营商的DNS就得到com域的IP地址。
	4. 运营商的DNS得到com域的IP地址之后又向com域的IP地址发起地址请求（问一下www.abc.com这个域名的IP地址是多少啊？）。com域这台服务器告诉运营商的DNS我不知道www.abc.com这个域名的IP地址，但是我知道abc.com这个域名的DNS地址，你去找它吧。
	5. 运营商的DNS又向abc.com这个域名的DNS地址发起请求，（问一下www.abc.com这个域名的IP地址是多少？）
	6. 这个时候abc.com域的DNS服务器在本地查找。把找到的结果发给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.abc.com对应的IP地址，并返回给Windows系统内核，内核就把这个结果返回给浏览器，最终浏览器得到这个IP地址，进行下一步动作。



### TCP三次握手，为什么要三次握手

**连接过程：**

1. 客户端首先发送一个连接试探。
2. 服务器监听到连接请求报文后，如果同意建立连接，则向Client发送确认。
3. Client收到确认后还需要再次发送确认，同时携带要发送给Server的数据。

**为什么：**

1. 验证服务端和客户端是否遵循TCP/IP协议
2. 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。



### 为什么HTTP 协议要基于 TCP 来实现

TCP是一个端到端的可靠的面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）



### 四次挥手，为什么

**过程：**

1. 客户端进程发出连接释放报文，并且停止发送数据。
2. 服务器收到连接释放报文，发出确认报文，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。(客户端向服务器方向释放了，但是服务器发送数据，客户端依然要接受)
3. 客户端收到服务器的确认请求后，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，客户端就进入了TIME-WAIT（时间等待）状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。（服务器结束TCP连接的时间要比客户端早一些。）

**为什么：**

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。



### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。



### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器。但是客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



## 什么是域名发散和域名收敛

1、域名发散

- 为了突破浏览器对于同一域名并发请求数的限制，http 静态资源采用多个子域名，通常为2～4个。
- 目的是充分利用现代浏览器的多线程并发下载能力。

2、域名收敛

- 域名收敛和域名发散正好相反：就是将静态资源只放在一个域名下面，而非发散情况下的多个域名下。
- 主要是为了适应移动端的发展需求。



## 为什么浏览器要做并发限制呢

以前网速慢、服务器硬件设备差、负载能力差，容易崩溃，所以要对最大并发数进行限制



## 什么是 DDoS 攻击，DDoS 攻击方式，如何应对 DDoS 攻击

分布式拒绝服务攻击(Distributed denial of service attack)，向目标系统同时提出数量庞大的服务请求。

**攻击方式：**

1. 通过使网络过载来干扰甚至阻断正常的网络通讯；
2. 通过向服务器提交大量请求，使服务器超负荷；
3. 阻断某一用户访问服务器；
4. 阻断某服务与特定系统或个人的通讯

**如何应对：**

1. 黑名单
2. DDOS 清洗：对用户请求数据进行实时监控，及时发现DOS攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。
3. CDN 加速
4. 高防服务器：高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点



## 什么是面向连接协议，面向无连接协议又是什么

1. 面向连接协议：通信双方在通信时，要事先建立好一条通信线路（虚拟的）。其过程有建立连接、维护连接、释放（断开）连接三个过程。TCP 是面向无连接的。
2. 面向无连接协议：与面向连接相对，面向无连接是指通信双方不需要事先建立通信线路，而是把每个带有目的地址的报文分组送到线路上，由系统自主选定线路进行传输。面向无连接只有**“**传送数据**”**的过程。UDP 是面向无连接的。



## http 请求方式有哪些

1. GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据。
2. HEAD：请求一个与GET请求的响应相同的响应，但没有响应体。
3. POST：将实体提交到指定的资源。
4. PUT：请求有效载荷替换目标资源的所有当前表示。
5. DELETE：删除指定的资源。
6. OPTIONS：用于描述目标资源的通信选项。
7. PATCH：对资源应用部分修改。
8. CONNECT：建立一个到由目标资源标识的服务器的隧道。
9. TRACE：沿着到目标资源的路径执行一个消息环回测试。



## TCP 和 UDP 的区别以及应用场景

|     名称     |                             UDP                              |                   TCP                   |
| :----------: | :----------------------------------------------------------: | :-------------------------------------: |
|     层级     |                            传输层                            |                 传输层                  |
|   有无连接   |                         面向无连接的                         |              面向有连接的               |
| 连接是否可靠 |                     不需要建立可靠的连接                     |          需要事先建立可靠连接           |
|   面向内容   |                           面向报文                           |               面向字节流                |
|     限制     | 发送一些比较小的包文件时没有错误处理机制，包没了就是没了。可以做一些处理，比如超时重发 |           出现错误会自动重传            |
|   通信方式   |              一对一、一对多、多对一、多对多通信              |               一对一通信                |
|   适用应用   |                        适用于实时应用                        |          适用于可靠传输的应用           |
|   适用场景   |        app应用，DNS 查找，广播传输、流媒体，线上游戏         | web browsing，email，文件传输，线上游戏 |



## GET 和 POST 的区别

- 简单来说：GET产生一个TCP数据包，POST产生两个TCP数据包
- 严格的说：
	- 对于GET方式的请求，游览器会把http header和data一并发送出去，服务器响应200（返回数据）；
	- 而对于POST请求。游览器先发送header，服务器响应100 continue，游览器再发送 data，服务器响应200 ok（返回数据）

> 这个问题。我相信只要你说你做过接口测试，基本上都被问到过
>
> 千万别说什么POST比GET安全什么的。这样一下子面试官就知道你的底子了。



## cookie 机制和 session 机制的区别

1. cookies数据保存在客户端。session数据保存在服务端
2. cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗
3. session安全一点，但是占用服务器资源。
4. Cookie 具有不可跨域名性，即访问a网站的时候不会同时携带b网站的 cookie
5. Session是另一种记录客户状态的机制。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。
6. 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。



## Internet 采用哪种网络协议，该协议的主要层次结构是什么

![image-20230509193629942](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230509193629942.png)

![image-20230509193644137](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230509193644137.png)



## IP 地址的编码分为哪两部分

IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。



## TCP/IP 通信建立的过程怎样，端口有什么作用

![image-20230509193940605](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230509193940605.png)

![image-20230509193951622](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230509193951622.png)

1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
2. 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
4. 确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。



**TCP的包头结构：**

1. 第一次握手：客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
2. 第二次握手：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。
3. 第三次握手：客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1

**关闭连接：**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。



**深入理解TCP连接的释放：**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。

简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：

1. 服务器读通道关闭

2. 客户机写通道关闭

3. 客户机读通道关闭

4. 服务器写通道关闭

关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。



**详细过程：**

第一阶段 客户机发送完数据之后，向服务器发送一个FIN数据段，序列号为i；

1. 服务器收到FIN(i)后，返回确认段ACK，序列号为i+1，关闭服务器读通道；
2. 客户机收到ACK(i+1)后，关闭客户机写通道；

（此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）

第二阶段 服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；

3. 客户机收到FIN(j)后，返回确认段ACK，序列号为j+1，关闭客户机读通道；

4. 服务器收到ACK(j+1)后，关闭服务器写通道。

这是标准的TCP关闭两个阶段，服务器和客户机都可以发起关闭，完全对称。

FIN标识是通过发送最后一块数据时设置的，标准的例子中，服务器还在发送数据，所以要等到发送完的时候，设置FIN（此时可称为TCP连接处于半关闭状态，因为数据仍可从被动关闭一方向主动关闭方传送）。如果在服务器收到FIN(i)时，已经没有数据需要发送，可以在返回ACK(i+1)的时候就设置FIN(j)标识，这样就相当于可以合并第二步和第三步。

TCP的TIME_WAIT和Close_Wait状态

除了ESTABLISHED，可以看到连接数比较多的几个状态是：FIN_WAIT1, TIME_WAIT,CLOSE_WAIT, SYN_RECV和LAST_ACK；下面的文章就这几个状态的产生条件、对系统的影响以及处理方式进行简单描述。

下面看下大家一般比较关心的三种TCP状态:

SYN_RECV : 服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。有两个相关系统配置：

CLOSE_WAIT: 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。

TIME_WAIT： 根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方socket将进入TIME_WAIT状态。TIME_WAIT状态将持续2个MSL(Max SegmentLifetime),在Windows下默认为4分钟，即240秒。TIME_WAIT状态下的socket不能被回收使用。具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。

为什么需要TIME_WAIT？TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。

为了方便描述，我给这个TCP连接的一端起名为Client，给另外一端起名为Server。上图描述的是Client主动关闭的过程，FTP协议中就这样的。如果要描述Server主动关闭的过程，只要交换描述过程中的Server和Client就可以了，HTTP协议就是这样的。

**描述过程：**

Client调用close()函数，给Server发送FIN，请求关闭连接；Server收到FIN之后给Client返回确认ACK，同时关闭读通道（不清楚就去看一下shutdown和close的差别），也就是说现在不能再从这个连接上读取东西，现在read返回0。此时Server的TCP状态转化为CLOSE_WAIT状态。

Client收到对自己的FIN确认后，关闭写通道，不再向连接中写入任何数据。

接下来Server调用close()来关闭连接，给Client发送FIN，Client收到后给Server回复ACK确认，同时Client关闭读通道，进入TIME_WAIT状态。

Server接收到Client对自己的FIN的确认ACK，关闭写通道，TCP连接转化为CLOSED，也就是关闭连接。

Client在TIME_WAIT状态下要等待最大数据段生存期的两倍，然后才进入CLOSED状态，TCP协议关闭连接过程彻底结束。

以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。

从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。为什么要这样做而不是直接进入CLOSED状态？

原因有二：

1. 保证TCP协议的全双工连接能够可靠关闭
2. 保证这次连接的重复数据段从网络中消失

先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。



## IP 组播有哪些好处

Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧消耗和网络拥挤问题。组播是一种允许一个或多个发送者(组播源)发送单一的数据包到多个接收者(一次的，同时的)的网络技术。组播可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播技术的核心就是针对如何节约网络资源的前提下保证服务质量。



https://www.cnblogs.com/cbslock/p/10139160.html

https://blog.csdn.net/yicixing7/article/details/79320821

https://www.cnblogs.com/6J2B2/p/12980363.html



## HTTP 2 项目设定目标

1. 页面加载时间 (PLT) 减少 50%。
2. 无需网站作者修改任何内容。
3. 将部署复杂性降至最低，无需变更网络基础设施。
4. 与开源社区合作开发此新协议。
5. 收集真实性能数据，验证实验性协议是否有效



## HTTP 2 特性

1. 二进制分帧层：HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。
2. 多路复用(请求与响应复用)：HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。
3. 数据流优先级：将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。 为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系：
	- 可以向每个数据流分配一个介于 1 至 256 之间的整数。
	- 每个数据流与其他数据流之间可以存在显式依赖关系。
4. 每个来源一个连接：每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。 因此，所有HTTP/2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。
5. 流控制：流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力：发送方可能非常繁忙、处于较高的负载之下，也可能仅仅希望为特定数据流分配固定量的资源。
6. 服务器推送：HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。
7. 标头压缩：每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：
	- 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。
	- 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。



## 什么是缓存，有什么用，你知道有哪些缓存方式，缓存的位置，http 缓存怎样生效？

**缓存的定义**：缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

**缓存的作用**：

1. 可以显著提高网站和应用程序的性能。
2. 减少了等待时间和网络流量
3. 减少了显示资源表示形式所需的时间。
4. 使页面更加响应性。
5. 缓解服务器端压力，提升性能。

**缓存的方式：**

- 浏览器缓存
- 代理缓存
- 网关缓存
- CDN缓存
- 反向代理缓存

**缓存的位置：**

- Service Worker：Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
- Memory Cache：读取高效，但是持续性很短，一旦关闭 Tab 页面，内存中的缓存也就被释放了。
- Disk Cache：读取速度慢，容量和存储时效性上有优势
- Push Cache：读取速度慢，容量和存储时效性上有优势

**缓存是怎样生效的：**

http缓存分为强制缓存和协商缓存

1. 强制缓存：强制缓存就是文件直接从缓存中获取，不需要发送请求

2. 协商缓存：协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置。协商缓存还是会发送请求的。

3. 强缓存-Cache-Control：Cache-Control 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。

4. 缓存请求指令

	```http
	Cache-Control: max-age=<seconds>
	Cache-Control: max-stale[=<seconds>]
	Cache-Control: min-fresh=<seconds>
	Cache-control: no-cache
	Cache-control: no-store
	Cache-control: no-transform
	Cache-control: only-if-cached
	```

5. 缓存响应指令

	```http
	Cache-control: must-revalidate
	Cache-control: no-cache
	Cache-control: no-store
	Cache-control: no-transform
	Cache-control: public
	Cache-control: private
	Cache-control: proxy-revalidate
	Cache-Control: max-age=<seconds>
	Cache-control: s-maxage=<seconds>
	```

	

## HTTP2 的伪头字段

伪头部字段是http2内置的几个特殊的以”:”开始的 key，用于替代HTTP/1.x中请求行/响应行中的信息，比如请求方法，响应状态码等

- :method 目标URL模式部分(请求)
- :scheme 目标URL模式部分(请求)
- :authority 目标URL 认证部分(请求)
- :path 目标URL的路径和查询部分(绝对路径 产生式和一个跟着"?"字符的查询产生式)。（请求）
- :status 响应头中的HTTP状态码部分(响应)



## HTTP 2:服务器推送

- HTTP 2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。
- HTTP 2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流
- 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。
- 推送资源可以进行以下处理:
	1. 由客户端缓存
	2. 在不同页面之间重用
	3. 与其他资源一起复用
	4. 由服务器设定优先级
	5. 被客户端拒绝



## 队首阻塞问题

- HTTP/1.1 和 HTTP/2 都存在队头阻塞问题(Head of line blocking)
- HTTP/1.1 的队头阻塞。一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样 就浪费了带宽资源。
- HTTP/2 的多路复用虽然可以解决“请求”这个粒度的阻塞，但 HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题。
- 由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题。
- 队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢。
- 那 QUIC 解决队头阻塞问题的的方法:
	1. QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、 传输、解密都基于Packet，这样就能避免 TLS 的队头阻塞问题;
	2. QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理



## Transport 头域

- Connection: close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了） keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）
- Host：指定被请求资源的Internet主机和端口号



## 时效缓存（强制缓存）

Cache-Control （低版本浏览器用的是Expires，了解即可）是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。

- private: 客户端可以缓存
- public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
- max-age=xxx: 缓存的内容将在 xxx 秒后失效
- no-cache: 需要使用对比缓存来验证缓存数据
- no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）



## 非时效缓存（对比缓存，用的是标识）

他用的不是时效时间max-age

第一次请求的时候，返回给客户端数据和缓存的信息，也就是一个特定的缓存标识，客户端把这个缓存标识放到缓存数据库，再次请求时 客户端先把缓存标识也一起发给服务端，进行对比，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。



## 两种缓存标识

Etag （唯一标识）优先级更高

Last-Modified/If-Modified-Since 返回给客户端最后这个资源的修改时间，优先级没有 Etag高

对比缓存标识生效不生效时，状态码200，服务端返回 body和 header

在对比缓存标识生效时，状态码为304，并且报文大小和请求时间大大减少。

原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。



## Service Worker

比如页面引入了一个 JQuery，对于页面来说这个脚本就是一个工具库，基本上是不会发生变化的，对于这种资源可以将它的缓存时间设置得长一点，比如如下这个地址的脚本是一个注册在指定源和路径下的事件驱动 worker；特点是：

- 运行在 worker 上下文，因此它不能访问 DOM；
- 独立于主线程之外，不会造成阻塞；
- 设计完全异步，所以同步 API（如 XHR 和 localStorage ）不能在 Service Worker中使用；
- 最后处于安全考虑，必须在 HTTPS 环境下才可以使用；

说了这么多特点，那它和缓存有啥关系？其实它有一个功能就是离线缓存：Service Worker Cache；区别于浏览器内部的 memory cache 和 disk cache，它允许我们自己去操控缓存，具体操作过程可以参看 [Using_Service_Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)；通过 Service Worker 设置的缓存会出现在浏览器开发者工具 Application 面板下的 Cache Storage 中。



## memory cache

是浏览器内存中的缓存，相比于 disk cache 它的特点是读取速度快，但容量小，且时效性短，一旦浏览器 tab 页关闭，memory cache 就将被清空。memory cache 会自动缓存所有资源嘛？答案肯定是否定的，当 HTTP 头设置了 Cache-Control: no-store 的时候或者浏览器设置了 Disabled cache 就无法把资源存入内存了，其实也无法存入硬盘。当从memory cache 中查找缓存的时候，不仅仅会去匹配资源的 URL，还会看其 Content-type是否相同



## disk cache

也叫 HTTP cache 是存在硬盘中的缓存，根据 HTTP 头部的各类字段进行判定资源的缓存规则，比如是否可以缓存，什么时候过期，过期之后需要重新发起请求吗？相比于 memory cache 的 disk cache 拥有存储空间时间长等优点，网站中的绝大多数资源都是存在 disk cache 中的。



> 浏览器如何判断一个资源是存入内存还是硬盘呢？关于这个问题，网上说法不一，不过比较靠谱的观点是：对于大文件大概率会存入硬盘中；当前系统内存使用率高的话，文件优先存入硬盘。
>
> 缓存按照缓存位置划分，其实还有一个 HTTP/2 的内容 push cache，由于目前国内对 HTTP/2 应用还不广泛，且网上对 push cache 的知识还不齐全，所以本篇不打算介绍这块，感兴趣的可以阅读这篇文章：[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)

https://juejin.cn/post/6844904135137951758

https://blog.csdn.net/zouzixuan/article/details/84677548

https://juejin.cn/post/6911482888491892749



## https 的访问过程

1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
3. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. Web服务器利用自己的私钥解密出会话密钥。
6. Web服务器利用会话密钥加密与客户端之间的通信。

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230510173825118.png" alt="image-20230510173825118" style="zoom:67%;" />

**详细解释：**

1. 客户端发起HTTPS请求：用户在浏览器里输入一个https网址，然后连接到server的443端口。
2. 服务端的配置：就是指上述提到的数字证书；
3. 传送证书：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
4. 客户端解析证书：客户端会对证书进行判断，验证公钥是否有效，存在问题弹出会警告；若没有问题，生成一个随机值（私钥），然后用证书继续进行加密；
5. 传送加密信息：客户端将加密后的随机值（私钥）提供给服务端，服务端会对其进行解密；
6. 服务端解密信息：服务端解密后得到随机值（私钥），然后把内容通过该值进行对称加密。对称加密就是指把要返回的信息和随机值（私钥）混合加密，这样除非知道随机值（私钥），不然无法获取数据。
7. 传输加密后的信息：继续将加密后的信息传递给客户端；
8. 客户端解密信息：客户端用之前生成的私钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。



## https 的优缺点

**优点：**

- 正确发送数据到客户端：使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
- 更安全：HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
- 增加中间人攻击的成本：HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
- 搜索排名更高：谷歌在2014跳转搜索算法，采用HTTPS加密的网站在搜索结果中的排名将会更高百度也在2018年发布百度对HTTPS站点的扶持态度，表明HTTPS将作为优质特征之一影响搜索排序。

**缺点：**

- 页面渲染更耗时间：因为SSL的缘故，HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%；
- 成本增加：SSL证书需要花钱，功能越强大的证书费用越高；
- HTTPS连接缓存不如HTTP高效：HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
- SSL证书通常需要绑定IP：SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
- 有局限性：HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。



## https 如何进行性能优化（访问速度和计算性能）

**https访问速度优化**

1. 设置HSTS
	- 服务端返回一个 HSTS 的 http header，浏览器获取到 HSTS 头部之后，在一段时间内，不管用户输入www.baidu.com还是http://www.baidu.com，都会默认将请求内部跳转成https://www.baidu.com。
2. Session resume
	- Session Resume 顾名思义就是复用 Session，实现简化握手。
	- 减少了 CPU 消耗，因为不需要进行非对称密钥交换的计算。
	- 提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。
3. Nginx设置Ocsp stapling
	- OSCP Stapling 工作原理简单来说就是浏览器发起 Client Hello 时会携带一个 certificate status request 的扩展，服务端看到这个扩展后将 OCSP 内容直接返回给浏览器，完成证书状态检查。由于浏览器不需要直接向 CA 站点查询证书状态，这个功能对访问速度的提升非常明显。
4. 使用 SPDY 或者 HTTP2
	- SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。HTTP2支持多路复用，有同样的效果。
	-  SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。
	- SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。
5. False start
	- 简单概括 False Start 的原理就是在 client_key_exchange 发出时将应用层数据一起发出来，能够节省一个 RTT。

**https计算性能优化**

1. 优先使用 ECC椭圆加密算术：ECC 椭圆加密算术相比普通的离散对数计算速度性能要强很多。

	<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230510183615278.png" alt="image-20230510183615278" style="zoom:67%;" />

2. 使用最新版的 openssl：一般来讲，新版的 OpenSSL 相比老版的计算速度和安全性都会有提升。

3. 硬件加速方案：

	1. SSL 专用加速卡
	2. GPUSSL 加速

4. TLS 远程代理计算



## http 和 https

- HTTP：(HyperText Transfer Protocol)超文本传输协议
- HTTPS：(Hypertext Transfer Protocol Secure)超文本传输安全协议

HTTP和HTTPS协议的主要区别如下：

1. HTTPS协议需要CA证书，费用较高，HTTP协议不需要
2. HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议
3. 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS的协议端口是443
4. HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全



## https 为什么是安全的

HTTPS相对于HTTP协议，加入了TLS/SSL，它的全称为安全传输层协议，是介于TCP和HTTP之间的一层安全协议。

TLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

<img src="http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230510184044243.png" alt="image-20230510184044243" style="zoom:67%;" />



## https 相对于 http 的缺陷

- HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂
- HTTPS协议握手阶段比较费时，增加页面的加载时间
- SSL证书是收费的，功能越强大的证书费用越高
- HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本



## 为什么需要证书

防止中间人攻击,验证服务器身份



## 怎么防止篡改

证书是公开的,虽然中间人可以拿到证书,但私钥无法获取,公钥无法推断出私钥,所以篡改后不能用私钥加密,强行加密客户也无法解密,强行修改内容,会导致证书内容与签名中的指纹不匹配

https://blog.csdn.net/qq_42033567/article/details/107902340

https://www.cnblogs.com/Duikerdd/p/12030955.html



## 状态码

![image-20230508194708960](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230508194708960.png)

![image-20230508194721527](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230508194721527.png)

![image-20230508194732835](http://images.xiaohai-hx.cn/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230508194732835.png)
